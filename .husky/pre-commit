#!/bin/sh
# Exit on any error
set -e

echo "Running pre-commit hook..."

# Check if there are any staged files
if [ -z "$(git diff --cached --name-only)" ]; then
  echo "No staged files to format"
  exit 0
fi

# Store the hash of staged changes to detect modifications
STAGED_HASH=$(git diff --cached | sha256sum | cut -d' ' -f1)

# Save list of staged files (handling all file states)
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACMR)
PARTIALLY_STAGED=$(git diff --name-only)

# Filter out migration files from formatting
STAGED_FILES=$(echo "$STAGED_FILES" | grep -v "packages/db/src/migrations/" || true)
PARTIALLY_STAGED=$(echo "$PARTIALLY_STAGED" | grep -v "packages/db/src/migrations/" || true)

# Stash unstaged changes to preserve working directory
# --keep-index keeps staged changes in working tree
git stash push --quiet --keep-index --message "pre-commit-stash" || true
STASHED=$?

# Separate TypeScript and Python files
TS_FILES=$(echo "$STAGED_FILES" | grep -E '\.(ts|tsx|js|jsx)$' || true)
PY_FILES=$(echo "$STAGED_FILES" | grep -E '\.py$' || true)

FORMAT_EXIT_CODE=0

# Run TypeScript formatter (Ultracite/Biome)
if [ -n "$TS_FILES" ]; then
  echo "Formatting TypeScript files with Ultracite..."
  bun x ultracite fix $TS_FILES
  TS_EXIT_CODE=$?
  if [ $TS_EXIT_CODE -ne 0 ]; then
    FORMAT_EXIT_CODE=$TS_EXIT_CODE
  fi
fi

# Run Python formatter and linter (Ruff)
if [ -n "$PY_FILES" ]; then
  echo "Formatting Python files with Ruff..."
  
  # Check if uv is available
  if command -v uv &> /dev/null; then
    # Format Python files
    uv run ruff format $PY_FILES
    PY_FORMAT_EXIT=$?
    
    # Check Python files with Ruff linter and fix
    uv run ruff check --fix $PY_FILES
    PY_CHECK_EXIT=$?
    
    # Check Python files with Pyrefly for type safety
    echo "Checking Python types with Pyrefly..."
    PY_TYPE_EXIT=0
    
    # Get unique app roots from src/ files
    APP_ROOTS=$(echo "$PY_FILES" | grep "src/" | sed 's|/src/.*||' | sort | uniq || true)
    
    if [ -n "$APP_ROOTS" ]; then
      for APP_ROOT in $APP_ROOTS; do
        echo "Checking $APP_ROOT..."
        
        if [ -f "$APP_ROOT/pyproject.toml" ]; then
          # Ensure app dependencies are installed
          (cd "$APP_ROOT" && uv sync --quiet 2>/dev/null || true)
          # Run pyrefly from the app directory
          if (cd "$APP_ROOT" && uv run pyrefly check "src/atlas_workers/workers" 2>&1 | grep -q "ERROR"); then
            PY_TYPE_EXIT=1
          fi
        fi
      done
    fi
    
    if [ $PY_FORMAT_EXIT -ne 0 ] || [ $PY_CHECK_EXIT -ne 0 ] || [ $PY_TYPE_EXIT -ne 0 ]; then
      FORMAT_EXIT_CODE=1
    fi
  else
    echo "Warning: uv not found. Skipping Python checks."
  fi
fi

# Restore working directory state
if [ $STASHED -eq 0 ]; then
  # Re-stage the formatted files
  if [ -n "$STAGED_FILES" ]; then
    echo "$STAGED_FILES" | while IFS= read -r file; do
      if [ -f "$file" ]; then
        git add "$file"
      fi
    done
  fi
  
  # Restore unstaged changes
  git stash pop --quiet || true
  
  # Restore partial staging if files were partially staged
  if [ -n "$PARTIALLY_STAGED" ]; then
    for file in $PARTIALLY_STAGED; do
      if [ -f "$file" ] && echo "$STAGED_FILES" | grep -q "^$file$"; then
        # File was partially staged - need to unstage the unstaged parts
        git restore --staged "$file" 2>/dev/null || true
        git add -p "$file" < /dev/null 2>/dev/null || git add "$file"
      fi
    done
  fi
else
  # No stash was created, just re-add the formatted files
  if [ -n "$STAGED_FILES" ]; then
    echo "$STAGED_FILES" | while IFS= read -r file; do
      if [ -f "$file" ]; then
        git add "$file"
      fi
    done
  fi
fi

# Check if staged files actually changed
NEW_STAGED_HASH=$(git diff --cached | sha256sum | cut -d' ' -f1)
if [ "$STAGED_HASH" != "$NEW_STAGED_HASH" ]; then
  echo "âœ¨ Files formatted by Ultracite"
fi

exit $FORMAT_EXIT_CODE
